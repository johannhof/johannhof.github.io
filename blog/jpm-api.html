<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>jpm as a Node module</title>
    <link href='https://fonts.googleapis.com/css?family=Muli:400,300' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//writ.cmcenroe.me/1.0.2/writ.min.css">
    <link rel="stylesheet" href="/style.css" type="text/css" media="all" />
  </head>
<body data-route=blog>
<nav class="menu">
  <a class="menu-item " href="/about/">Johann</a>
  <a class="menu-item current" href="/">Blog</a>
  <a class="menu-item " href="/talks/">Talks</a>
  <a class="menu-item" href="http://github.com/johannhof">GitHub</a>
  <a class="menu-item" href="https://getpocket.com/@jprimero">Reading List</a>
  <a class="menu-item" href="http://twitter.com/johannh">Twitter</a>
  <hr>
</nav>
<main>
  <h1 id='jpm_as_a_node_module'>jpm as a Node module</h1>

<p>Despite my personal involvement in <a href='https://github.com/mozilla-jetpack/jpm'>jpm</a> we've used <a href='https://developer.mozilla.org/en-US/Add-ons/SDK/Tools/cfx'>cfx</a> at <a href='https://zenmate.com'>ZenMate</a> for building our Addon-SDK based Firefox extensions until it finally <a href='https://blog.mozilla.org/addons/2015/10/14/breaking-changes-let-const-firefox-nightly-44/'>became obsolete</a>. With cfx-based Addons now being more or less automatically rejected from <a href='https://addons.mozilla.org'>addons.mozilla.org</a>, we made the transition to jpm.</p>

<p>This was long overdue, since jpm is better supported and installable from npm. As a bonus, we can finally <code>require('jpm')</code> in our build tools instead of using <code>child_process.spawn</code> to run a cfx command.</p>

<p>We found that the internal jpm API is largely unknown and almost undocumented, so I thought this would be interesting to share.</p>

<h2 id='requiring'>Requiring</h2>

<p>Almost all commands that you can run in jpm (init, run, xpi, test, post, sign) have a corresponding module in <code>jpm/lib</code>. That module exposes a function as its <code>module.exports</code>, which does exactly what the CLI command would do. So, to use <code>jpm run</code>, you can do</p>

<pre><code>var run = require('jpm/lib/run');</code></pre>

<h2 id='running'>Running</h2>

<p>Here's a summary of the functions signatures:</p>

<pre><code>init()
run(manifest, options)
test(manifest, options)
xpi(manifest, options)
post(manifest, options)
sign(options, config)</code></pre>

<p><code>manifest</code> simply means the <code>package.json</code> of your addon as a JavaScript object.</p>

<p><code>options</code> is an object where keys correspond to the CLI flags that are used by the different commands. Note that keys in options are camelCased, while command-line flags use dashes. So <code>addon-dir</code> becomes <code>addonDir</code>.</p>

<p><code>xpi</code> and <code>post</code> take an additional option that is not specifiable on the command line: <code>xpiPath</code>. It determines the folder where the XPI should be saved. <code>run</code> and <code>test</code> will use a temporary location instead.</p>

<p><code>sign</code> takes <code>options</code> as its first parameter. The second parameter <code>config</code> takes can be used to override some internal mechanism, e.g. how the XPI should be created. You should check out the <a href='https://github.com/mozilla-jetpack/jpm/blob/master/lib/sign.js'>source code</a> for more info.</p>

<blockquote>
<p>Warning: jpm sign will automatically submit addons to AMO, if you try to sign a listed addon it will <a href='https://github.com/mozilla-jetpack/jpm/issues/467'>automatically be put up for review</a></p>
</blockquote>

<h2 id='full_example'>Full Example</h2>

<pre><code>var fs = require('fs');
var xpi = require('jpm/lib/xpi');

// get manifest contents 
var manifest = JSON.parse(fs.readFileSync('/path/to/your/addon/package.json', 'utf8'));

// like command line options
var options = {
  addonDir: '/path/to/your/addon',
  xpiPath: '/path/to/your/output/dir'
};

// create XPI
xpi(manifest, options).then(function(xpiPath) {
  console.log(&quot;XPI saved at&quot;, xpiPath);
}).catch(function(error) {
  console.error(error);
});</code></pre>

</main>
</body>
  <footer>
    <hr>
    <p><a href="https://github.com/cobalt-org/cobalt.rs">Built with Cobalt.</a></p>
    <br>
  </footer>
  </body>
</html>
